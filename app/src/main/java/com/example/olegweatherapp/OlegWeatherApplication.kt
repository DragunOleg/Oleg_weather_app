package com.example.olegweatherappimport android.app.Applicationimport android.content.Contextimport android.os.Buildimport androidx.work.*import com.example.olegweatherapp.work.RefreshDataWorkerimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.launchimport timber.log.Timberimport java.util.concurrent.TimeUnitclass OlegWeatherApplication : Application() {    private val applicationScope = CoroutineScope(Dispatchers.Default)    /**     * onCreate is called before the first screen is shown to the user.     *     * Use it to setup any background tasks, running expensive setup operations in a background     * thread to avoid delaying app start.     */    override fun onCreate() {        super.onCreate()        delayedInit()    }    private fun delayedInit() {        applicationScope.launch {            Timber.plant(Timber.DebugTree())            val sharedPref = getSharedPreferences("settings", Context.MODE_PRIVATE)            if(sharedPref != null) {                val period = sharedPref.getInt("updatePeriod",60)                setupRecurringWork(period)            }            else {                setupRecurringWork(60)            }        }    }}fun setupRecurringWork(minutes: Int) {    val constraints = Constraints.Builder()            .setRequiredNetworkType(NetworkType.UNMETERED)            .setRequiresCharging(true)            .setRequiresBatteryNotLow(true)            .apply {                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {                    setRequiresDeviceIdle(true)                }            }            .build()    val repeatingRequest = PeriodicWorkRequestBuilder<RefreshDataWorker>(minutes.toLong(), TimeUnit.MINUTES)            .setConstraints(constraints)            .build()    Timber.d("forecast: WorkManager: Periodic Work request for sync is scheduled, with ${minutes.toLong()} minutes")    WorkManager.getInstance().enqueueUniquePeriodicWork(            RefreshDataWorker.WORK_NAME,            ExistingPeriodicWorkPolicy.KEEP,            repeatingRequest)}